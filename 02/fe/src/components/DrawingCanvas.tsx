"use client";import React, { useRef, useEffect, useState, useCallback } from 'react';import { getStroke } from 'perfect-freehand';interface Point {    x: number;    y: number;    pressure?: number;}interface Stroke {    points: Point[];    color: string;    size: number;}interface PerfectFreehandOptions {    size?: number;    thinning?: number;    smoothing?: number;    streamline?: number;    easing?: (t: number) => number;    start?: { taper?: number; cap?: boolean };    end?: { taper?: number; cap?: boolean };    simulatePressure?: boolean;    last?: boolean;}const DrawingCanvas: React.FC = () => {    const canvasRef = useRef<HTMLCanvasElement>(null);    const [isDrawing, setIsDrawing] = useState(false);    const [currentStrokePoints, setCurrentStrokePoints] = useState<Point[]>([]);    const [strokes, setStrokes] = useState<Stroke[]>([]);    const [isLoading, setIsLoading] = useState(false);    const [ocrResults, setOcrResults] = useState([]);    const [errorMessage, setErrorMessage] = useState('');    const perfectFreehandOptions: PerfectFreehandOptions = {        size: 8, // Basic stroke size        smoothing: 0.5, // Stroke smoothness (0-1)        thinning: 0.5, // Thinning at the end of the stroke (0-1)        streamline: 0.5, // Degree of straightening (0-1)        easing: (t) => t, // Easing function, default is linear        start: {            taper: 0, // Thinning at the start of the stroke            cap: true, // Round the start of the stroke        },        end: {            taper: 100, // Thinning at the end of the stroke (larger value means thinner)            cap: true, // Round the end of the stroke        },        simulatePressure: false, // Set to false since we're using real pressure    };    // Current stroke color and size    const [currentColor, setCurrentColor] = useState<string>('#FFFFFF'); // Default color black    const [currentSize, setCurrentSize] = useState<number>(perfectFreehandOptions.size || 8); // Default size from options    // Function to draw a stroke (completed or in progress)    const drawStroke = useCallback((ctx: CanvasRenderingContext2D, stroke: Stroke) => {        if (stroke.points.length < 2) {            // If there's only 1 point, draw a small dot            if (stroke.points.length === 1) {                const point = stroke.points[0];                ctx.fillStyle = stroke.color;                ctx.beginPath();                // Draw a small circle instead of a freehand stroke                ctx.arc(point.x, point.y, stroke.size / 2, 0, Math.PI * 2);                ctx.fill();            }            return; // Perfect Freehand needs at least 2 points        }        // Get stroke options, override size        const optionsWithStrokeSize = { ...perfectFreehandOptions, size: stroke.size };        // Calculate the outline shape of the stroke        const outlinePoints = getStroke(stroke.points, optionsWithStrokeSize);        if (outlinePoints.length === 0) {            return; // No outline to draw        }        // Draw the outline on the canvas        ctx.fillStyle = stroke.color;        ctx.beginPath();        // Start from the first point of the outline        ctx.moveTo(outlinePoints[0][0], outlinePoints[0][1]);        // Connect the remaining points of the outline        for (let i = 1; i < outlinePoints.length; i++) {            ctx.lineTo(outlinePoints[i][0], outlinePoints[i][1]);        }        ctx.closePath(); // Close the path for filling        ctx.fill(); // Fill the stroke    }, [perfectFreehandOptions]); // Depends on perfectFreehandOptions    // Function to redraw the entire canvas    const redrawCanvas = useCallback(() => {        const canvas = canvasRef.current;        if (!canvas) return;        const ctx = canvas.getContext('2d');        if (!ctx) return;        // Clear all content on the canvas        ctx.clearRect(0, 0, canvas.width, canvas.height);        // Redraw all completed strokes        strokes.forEach(stroke => {            drawStroke(ctx, stroke);        });        // If drawing, draw the current stroke as well        if (isDrawing && currentStrokePoints.length > 0) {            // Temporarily create a stroke object for the current stroke to use drawStroke            const currentDrawingStroke: Stroke = {                points: currentStrokePoints,                color: currentColor,                size: currentSize            };            drawStroke(ctx, currentDrawingStroke);        }    }, [strokes, isDrawing, currentStrokePoints, currentColor, currentSize, drawStroke]);    // Set up canvas and attach/detach event listeners when component mounts/unmounts    useEffect(() => {        const canvas = canvasRef.current;        if (!canvas) return;        const ctx = canvas.getContext('2d');        if (!ctx) return;        // Set canvas dimensions (necessary for Canvas API)        // Can be made responsive by getting the parent div's dimensions        const container = canvas.parentElement;        if (container) {            canvas.width = container.clientWidth;            canvas.height = container.clientHeight;        } else {            // Default size if no parent container            canvas.width = 800;            canvas.height = 600;        }        // Handle component unmount to remove event listeners        return () => {            // Cleanup code if any specific listeners were attached here            // (Though we'll attach them directly to the canvas element in JSX for simplicity)        };    }, []); // Only run once when component mounts    // Use useEffect to redraw when strokes or currentStrokePoints change    // This helps update the canvas smoothly while drawing and when a stroke ends    useEffect(() => {        redrawCanvas();    }, [strokes, currentStrokePoints, isDrawing, redrawCanvas]); // Redraw when drawing-related states change    // Function to get point from mouse/touch event    const getCanvasPoint = (event: React.MouseEvent | React.TouchEvent): Point | null => {        const canvas = canvasRef.current;        if (!canvas) return null;        const rect = canvas.getBoundingClientRect();        let clientX, clientY, pressure;        if ('touches' in event) { // Touch event            const touch = event.touches[0];            if (!touch) return null;            clientX = touch.clientX;            clientY = touch.clientY;            pressure = touch.force || 0.5;            pressure = Math.min(Math.max(pressure, 0), 1);        } else { // Mouse event            clientX = event.clientX;            clientY = event.clientY;            pressure = 0.5; // Default pressure for mouse        }        const x = clientX - rect.left;        const y = clientY - rect.top;        return { x, y, pressure };    };    // Handle mouse/touch down event    const handlePointerDown = (event: React.MouseEvent | React.TouchEvent) => {        // Only handle left mouse button or single touch        if ('button' in event && event.button !== 0) return; // Only left mouse button        if ('touches' in event && event.touches.length > 1) return; // Only single touch        const point = getCanvasPoint(event);        if (!point) return;        // Prevent scrolling on mobile when touching the canvas        event.preventDefault();        setIsDrawing(true);        setCurrentStrokePoints([point]);        // Redraw immediately to show the first point        // redrawCanvas(); // Redraw will be called by useEffect when currentStrokePoints changes    };    // Handle mouse/touch move event    const handlePointerMove = (event: React.MouseEvent | React.TouchEvent) => {        if (!isDrawing) return;        const point = getCanvasPoint(event);        if (!point) return;        // Prevent scrolling on mobile when touching the canvas        event.preventDefault();        // Add new point to the current stroke        setCurrentStrokePoints(prevPoints => [...prevPoints, point]);        // Redraw will be called by useEffect when currentStrokePoints changes    };    // Handle mouse/touch up or leave canvas event    const handlePointerUp = () => {        if (!isDrawing) return;        setIsDrawing(false);        // If there are enough points for a stroke (e.g., > 1 point), save it        if (currentStrokePoints.length > 1) {            const newStroke: Stroke = {                points: currentStrokePoints,                color: currentColor,                size: currentSize            };            setStrokes(prevStrokes => [...prevStrokes, newStroke]);        } else if (currentStrokePoints.length === 1) {            // If there's only 1 point, handle it as a dot            const newStroke: Stroke = {                points: currentStrokePoints, // Still save that point                color: currentColor,                size: currentSize            };            setStrokes(prevStrokes => [...prevStrokes, newStroke]);        }        // Clear current stroke points        setCurrentStrokePoints([]);        // Redraw will be called by useEffect when strokes changes    };    // Function to clear the entire canvas    const handleClearCanvas = () => {        setStrokes([]); // Clear all strokes        setCurrentStrokePoints([]); // Clear current stroke in progress (if any)        // Redraw will be called by useEffect    };    // Function to handle color change    const handleColorChange = (e: React.ChangeEvent<HTMLInputElement>) => {        setCurrentColor(e.target.value);    };    // Function to handle stroke size change    const handleSizeChange = (e: React.ChangeEvent<HTMLInputElement>) => {        setCurrentSize(parseInt(e.target.value, 10));    };    const handleExportToPNG = useCallback(async () => {        if (!canvasRef.current) return;                try {          // Set loading state            setIsLoading(true);                        // Lấy dữ liệu từ canvas dưới dạng Blob            const canvas = canvasRef.current;            const dataUrl = canvas.toDataURL('image/png');                        // Convert DataURL sang Blob            const res = await fetch(dataUrl);            const blob = await res.blob();                        // Tạo FormData để gửi đến server            const formData = new FormData();            formData.append('image', blob, 'drawing.png');                        // Thêm các tham số kích thước          // Giới hạn kích thước không quá 1600px            const maxWidth = Math.min(canvas.width, 1600);            const maxHeight = Math.min(canvas.height, 1600);            formData.append('max_width', maxWidth.toString());            formData.append('max_height', maxHeight.toString());                        // Gửi request đến server với thêm mode: 'cors'            const response = await fetch('http://localhost:8080/ocr', {                method: 'POST',                mode: 'cors', // Thêm mode cors                body: formData,            });                        if (!response.ok) {                throw new Error(`Server responded with status: ${response.status}`);            }                        // Parse và xử lý kết quả            const result = await response.json();                        // Hiển thị kết quả OCR            setOcrResults(result);            setErrorMessage('');                    } catch (error) {            console.error('Error during export to PNG and OCR:', error);          // Hiển thị thông báo lỗi            setErrorMessage(error instanceof Error ? error.message : 'Unknown error occurred');            setOcrResults([]);        } finally {          // Tắt loading state            setIsLoading(false);        }    }, [canvasRef]);    return (        <article className="mx-auto mx-4 flex flex-col items-center">            <h1 className="text-center text-3xl font-bold my-4">Vẽ Chữ Hán</h1>            <div className="w-full md:w-4/5 h-[50dvh] relative border rounded-md mx-auto flex justify-center items-center">                <canvas                    ref={canvasRef}                    onMouseDown={handlePointerDown}                    onMouseMove={handlePointerMove}                    onMouseUp={handlePointerUp}                    onMouseLeave={handlePointerUp}                    onTouchStart={handlePointerDown}                    onTouchMove={handlePointerMove}                    onTouchEnd={handlePointerUp}                    onTouchCancel={handlePointerUp}                    style={{ display: 'block', width: '100%', height: '100%' }} // Ensure canvas fills the container                />                                {/* Loading overlay khi đang xử lý */}                {isLoading && (                    <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center">                        <div className="flex flex-col items-center">                            <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-white"></div>                            <p className="text-white mt-2">Đang xử lý OCR...</p>                        </div>                    </div>                )}            </div>                        <div className="flex justify-center items-center gap-x-3 m-3 px-2 py-1.5 dark:bg-zinc-800 rounded-xl w-full md:w-4/5">                <p className="whitespace-nowrap">Chiều cao:</p>                <input type="range" min="1" max="64" className="w-full" value={currentSize} onChange={handleSizeChange} />                <p>{currentSize}px</p>            </div>            <div className="flex justify-center items-center gap-x-3 m-3 w-full md:w-4/5">                <span>Color:</span>                 <input type="color" value={currentColor} onChange={handleColorChange} className="h-8 w-8 rounded-full" />                <button onClick={handleClearCanvas} className="px-4 py-1.5 bg-red-500 hover:bg-red-600 text-white rounded-md">                    Clear All                </button>                <button                     onClick={handleExportToPNG}                     className="px-4 py-1.5 bg-blue-500 hover:bg-blue-600 text-white rounded-md flex items-center gap-2"                    disabled={isLoading}                >                    {isLoading ? (                        <>                            <div className="animate-spin h-4 w-4 border-t-2 border-b-2 border-white rounded-full"></div>                            <span>Đang xử lý...</span>                        </>                    ) : (                        <>                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />                            </svg>                            <span>Nhận diện chữ</span>                        </>                    )}                </button>            </div>            {/* Phần hiển thị kết quả OCR */}            {ocrResults && ocrResults.length > 0 && (                <div className="w-full md:w-4/5 mt-4 bg-gray-50 dark:bg-gray-800 p-4 rounded-md">                    <h2 className="text-xl font-bold mb-2">Kết quả OCR</h2>                    <ul className="space-y-2">                        {ocrResults.map((item, index) => (                            <li key={index} className="border-b pb-2 dark:border-gray-700">                                <div className="flex flex-col">                                    <span className="font-medium">Văn bản: {item.text}</span>                                    <span className="text-sm text-gray-500 dark:text-gray-400">                                        Độ tin cậy: {(item.confidence * 100).toFixed(1)}%                                    </span>                                </div>                            </li>                        ))}                    </ul>                </div>            )}            {/* Hiển thị thông báo lỗi nếu có */}            {errorMessage && (                <div className="w-full md:w-4/5 mt-4 bg-red-50 dark:bg-red-900 dark:bg-opacity-20 p-4 rounded-md text-red-600 dark:text-red-400">                    <h2 className="font-bold">Lỗi</h2>                    <p>{errorMessage}</p>                </div>            )}        </article>    );};export default DrawingCanvas;